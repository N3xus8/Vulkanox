use vulkano::{buffer::BufferContents, pipeline::graphics::vertex_input::Vertex as VertexInput};

// The next step is to create the shaders.
//
// The raw shader creation API provided by the vulkano library is unsafe for various reasons,
// so The `shader!` macro provides a way to generate a Rust module from GLSL source - in the
// example below, the source is provided as a string input directly to the shader, but a path
// to a source file can be provided as well. Note that the user must specify the type of shader
// (e.g. "vertex", "fragment", etc.) using the `ty` option of the macro.
//
// The items generated by the `shader!` macro include a `load` function which loads the shader
// using an input logical device. The module also includes type definitions for layout
// structures defined in the shader source, for example uniforms and push constants.
//
// A more detailed overview of what the `shader!` macro generates can be found in the
// vulkano-shaders crate docs. You can view them at https://docs.rs/vulkano-shaders/
pub mod vs {
    vulkano_shaders::shader! {
        ty: "vertex",
        src: r"
                #version 450

                layout(location = 0) out vec3 fragColor;

                vec2 positions[3] = vec2[](
                    vec2(0.0, -0.5),
                    vec2(0.5, 0.5),
                    vec2(-0.5, 0.5)
                );

                vec3 colors[3] = vec3[](
                    vec3(1.0, 0.0, 0.0),
                    vec3(0.0, 1.0, 0.0),
                    vec3(0.0, 0.0, 1.0)
                );


                void main() {
                    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);
                    fragColor = colors[gl_VertexIndex];
                }
            ",
    }
}

pub mod fs {
    vulkano_shaders::shader! {
        ty: "fragment",
        src: r"
                #version 450

                layout(location = 0) in vec3 fragColor;

                layout(location = 0) out vec4 outColor;

                void main(){
                    outColor = vec4(fragColor, 1.0);
                }
            ",
    }
}

#[derive(BufferContents, VertexInput)]
#[repr(C)]
pub struct Vertex {
    #[format(R32G32_SFLOAT)]
    pub position: [f32; 2],
}

pub const VERTICES: [Vertex; 3] = [
    Vertex {
        position: [-0.5, -0.25],
    },
    Vertex {
        position: [0.0, 0.5],
    },
    Vertex {
        position: [0.25, -0.1],
    },
];

pub const INDICES: [u32;3] = [0, 1, 1];
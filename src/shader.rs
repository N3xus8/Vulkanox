use vulkano::{buffer::BufferContents, pipeline::graphics::vertex_input::Vertex as VertexInput};

// The next step is to create the shaders.
//
// The raw shader creation API provided by the vulkano library is unsafe for various reasons,
// so The `shader!` macro provides a way to generate a Rust module from GLSL source - in the
// example below, the source is provided as a string input directly to the shader, but a path
// to a source file can be provided as well. Note that the user must specify the type of shader
// (e.g. "vertex", "fragment", etc.) using the `ty` option of the macro.
//
// The items generated by the `shader!` macro include a `load` function which loads the shader
// using an input logical device. The module also includes type definitions for layout
// structures defined in the shader source, for example uniforms and push constants.
//
// A more detailed overview of what the `shader!` macro generates can be found in the
// vulkano-shaders crate docs. You can view them at https://docs.rs/vulkano-shaders/
pub mod vs {
    vulkano_shaders::shader! {
        ty: "vertex",
        src: r"
                #version 460

                layout(location = 0) in vec3 position;
                layout(location = 1) in vec3 normal;

                layout(location = 0) out vec3 fragColor;
//                layout(location = 1) out vec3 out_normal;
               // layout(location = 1) in vec3 color;

               layout(set = 0, binding = 0) uniform data {
                    mat4 view_projection;
               } uniforms;


                layout(push_constant) uniform PushConstantData {
                    float time;
                } pc;


                void main() {
                   // Original gl_Position = vec4(position*sin(pc.time), 1.0);
                    gl_Position = uniforms.view_projection * vec4(position, 1.0);
                    //gl_Position =  vec4(position, 1.0);
                    fragColor = position ;
                }
            ",
    }
}

pub mod fs {
    vulkano_shaders::shader! {
        ty: "fragment",
        src: r"
                #version 460

                layout(location = 0) in vec3 fragColor;

                layout(location = 0) out vec4 outColor;

                layout(set = 0, binding = 1) uniform AmbientLight {
                    vec3 color;
                    float intensity;
                } ambient;

                layout(set = 0, binding = 2) uniform DirectionalLight {
                    vec3 position;
                    vec3 color;
                } directional;

                void main(){
                    vec3 ambient_color = ambient.intensity * ambient.color;
                    vec3 combined_color = ambient_color * fragColor;
                    outColor = vec4(combined_color, 1.0);
                    //outColor = vec4(fragColor, 1.0);
                }
            ",
    }
}

#[derive(Debug, BufferContents, VertexInput)]
#[repr(C)]
pub struct Vertex {
    #[format(R32G32B32_SFLOAT)]
    pub position: [f32; 3],
    #[format(R32G32B32_SFLOAT)]
    pub normal: [f32; 3],
}


use vulkano::{buffer::BufferContents, pipeline::graphics::vertex_input::Vertex as VertexInput};

// The next step is to create the shaders.
//
// The raw shader creation API provided by the vulkano library is unsafe for various reasons,
// so The `shader!` macro provides a way to generate a Rust module from GLSL source - in the
// example below, the source is provided as a string input directly to the shader, but a path
// to a source file can be provided as well. Note that the user must specify the type of shader
// (e.g. "vertex", "fragment", etc.) using the `ty` option of the macro.
//
// The items generated by the `shader!` macro include a `load` function which loads the shader
// using an input logical device. The module also includes type definitions for layout
// structures defined in the shader source, for example uniforms and push constants.
//
// A more detailed overview of what the `shader!` macro generates can be found in the
// vulkano-shaders crate docs. You can view them at https://docs.rs/vulkano-shaders/
pub mod vs {
    vulkano_shaders::shader! {
        ty: "vertex",
        src: r"
                #version 460

                layout(location = 0) in vec3 position;
                layout(location = 1) in vec3 normal;

                 layout(location = 2) in vec4 matrix1;
                 layout(location = 3) in vec4 matrix2;
                 layout(location = 4) in vec4 matrix3;
                 layout(location = 5) in vec4 matrix4;


                layout(location = 0) out vec3 fragColor;
                layout(location = 1) out vec3 out_normal;
                layout(location = 2) out vec3 frag_pos;
            
               // MVP 
               layout(set = 0, binding = 0) uniform MVP {
                    mat4 model;
                    mat4 view;
                    mat4 projection;
               } uniforms;

                // Use push constant for time. Time is available but no used.
                layout(push_constant) uniform PushConstantData {
                    float time;
                } pc;

                // Matrix for the instances
                mat4 model_matrix = mat4(
                        matrix1,
                        matrix2,
                        matrix3,
                        matrix4
                );

                void main() {
                   // Original gl_Position = vec4(position*sin(pc.time), 1.0);

                   // world view . Note: model aka local view
                   mat4 worldview = uniforms.view * model_matrix * uniforms.model;
                   
                   // Final coord with projection
                   gl_Position = uniforms.projection * worldview  * vec4(position, 1.0);
                    //gl_Position =  vec4(position, 1.0);

                    // Rainbow effect
                    fragColor = position ;

                    // Normal for the model
                    out_normal = mat3(uniforms.model) * normal;
                    frag_pos = vec3(uniforms.model * vec4(position, 1.0));            
                }
            ",
    }
}

pub mod fs {
    vulkano_shaders::shader! {
        ty: "fragment",
        src: r"
                #version 460

                layout(location = 0) in vec3 fragColor;
                layout(location = 1) in vec3 in_normal;
                layout(location = 2) in vec3 frag_pos;

                layout(location = 0) out vec4 outColor;

                layout(set = 0, binding = 1) uniform AmbientLight {
                    vec3 color;
                    float intensity;
                } ambient;

                layout(set = 0, binding = 2) uniform DirectionalLight {
                    vec3 position;
                    vec3 color;
                } directional;

                void main(){
                    // Ambient Light
                    vec3 ambient_color = ambient.intensity * ambient.color;

                    //  Directional Light
                    vec3 light_direction = normalize(directional.position - frag_pos);
                    float directional_intensity = max(dot(in_normal, light_direction), 0.0);
                    vec3 directional_color = directional_intensity * directional.color;

                    // Combined Ambient Light and directional Light
                    vec3 combined_color = (ambient_color + directional_color)  * fragColor;
                    outColor = vec4(combined_color, 1.0);
                    //outColor = vec4(fragColor, 1.0);
                }
            ",
    }
}

#[derive(Debug, BufferContents, Copy, Clone, VertexInput)]
#[repr(C)]
pub struct Vertex {
    #[format(R32G32B32_SFLOAT)]
    pub position: [f32; 3],
    #[format(R32G32B32_SFLOAT)]
    pub normal: [f32; 3],
}
